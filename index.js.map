{"version":3,"file":"index.js","sources":["node_modules/mobx-react/index.module.js","src/core.jsx"],"sourcesContent":["import { Atom, Reaction, extras, isObservableArray, isObservableMap, isObservableObject, spy, untracked } from 'mobx';\nimport { Children, Component, createElement } from 'react';\nimport { findDOMNode, unstable_batchedUpdates } from 'react-dom';\n\n// These functions can be stubbed out in specific environments\nvar unstable_batchedUpdates$1 = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar EventEmitter = function () {\n    function EventEmitter() {\n        classCallCheck(this, EventEmitter);\n        this.listeners = [];\n    }\n\n    createClass(EventEmitter, [{\n        key: \"on\",\n        value: function on(cb) {\n            var _this = this;\n\n            this.listeners.push(cb);\n            return function () {\n                var index = _this.listeners.indexOf(cb);\n                if (index !== -1) _this.listeners.splice(index, 1);\n            };\n        }\n    }, {\n        key: \"emit\",\n        value: function emit(data) {\n            this.listeners.forEach(function (fn) {\n                return fn(data);\n            });\n        }\n    }]);\n    return EventEmitter;\n}();\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\n\nvar defineProperty$1 = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\nvar hoistNonReactStatics = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n            }\n        }\n\n        var keys = getOwnPropertyNames(sourceComponent);\n\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try { // Avoid failures from read-only properties\n                    defineProperty$1(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n\n        return targetComponent;\n    }\n\n    return targetComponent;\n};\n\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validate) {\n    function checkType(isRequired, props, propName, componentName, location, propFullName) {\n        for (var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {\n            rest[_key - 6] = arguments[_key];\n        }\n\n        return untracked(function () {\n            componentName = componentName || \"<<anonymous>>\";\n            propFullName = propFullName || propName;\n            if (props[propName] == null) {\n                if (isRequired) {\n                    var actual = props[propName] === null ? \"null\" : \"undefined\";\n                    return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n                }\n                return null;\n            } else {\n                return validate.apply(undefined, [props, propName, componentName, location, propFullName].concat(rest));\n            }\n        });\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n    return chainedCheckType;\n}\n\n// Copied from React.PropTypes\nfunction isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true;\n    }\n\n    return false;\n}\n\n// Copied from React.PropTypes\nfunction getPropType(propValue) {\n    var propType = typeof propValue === \"undefined\" ? \"undefined\" : _typeof(propValue);\n    if (Array.isArray(propValue)) {\n        return \"array\";\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\";\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\";\n    }\n    return propType;\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue) {\n    var propType = getPropType(propValue);\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\";\n        } else if (propValue instanceof RegExp) {\n            return \"regexp\";\n        }\n    }\n    return propType;\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n        return untracked(function () {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;\n            }\n            var mobxChecker = void 0;\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = isObservableArray;\n                    break;\n                case \"Object\":\n                    mobxChecker = isObservableObject;\n                    break;\n                case \"Map\":\n                    mobxChecker = isObservableMap;\n                    break;\n                default:\n                    throw new Error(\"Unexpected mobxType: \" + mobxType);\n            }\n            var propValue = props[propName];\n            if (!mobxChecker(propValue)) {\n                var preciseType = getPreciseType(propValue);\n                var nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n                return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n            }\n            return null;\n        });\n    });\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {\n        for (var _len2 = arguments.length, rest = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n            rest[_key2 - 5] = arguments[_key2];\n        }\n\n        return untracked(function () {\n            if (typeof typeChecker !== \"function\") {\n                return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n            }\n            var error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName);\n            if (error instanceof Error) return error;\n            var propValue = props[propName];\n            for (var i = 0; i < propValue.length; i++) {\n                error = typeChecker.apply(undefined, [propValue, i, componentName, location, propFullName + \"[\" + i + \"]\"].concat(rest));\n                if (error instanceof Error) return error;\n            }\n            return null;\n        });\n    });\n}\n\nvar observableArray = createObservableTypeCheckerCreator(false, \"Array\");\nvar observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false);\nvar observableMap = createObservableTypeCheckerCreator(false, \"Map\");\nvar observableObject = createObservableTypeCheckerCreator(false, \"Object\");\nvar arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\");\nvar arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true);\nvar objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\");\n\n\n\nvar propTypes = Object.freeze({\n\tobservableArray: observableArray,\n\tobservableArrayOf: observableArrayOf,\n\tobservableMap: observableMap,\n\tobservableObject: observableObject,\n\tarrayOrObservableArray: arrayOrObservableArray,\n\tarrayOrObservableArrayOf: arrayOrObservableArrayOf,\n\tobjectOrObservableObject: objectOrObservableObject\n});\n\nfunction isStateless(component) {\n    // `function() {}` has prototype, but `() => {}` doesn't\n    // `() => {}` via Babel has prototype too.\n    return !(component.prototype && component.prototype.render);\n}\n\nvar injectorContextTypes = {\n    mobxStores: objectOrObservableObject\n};\nObject.seal(injectorContextTypes);\n\nvar proxiedInjectorProps = {\n    contextTypes: {\n        get: function get$$1() {\n            return injectorContextTypes;\n        },\n        set: function set$$1(_) {\n            console.warn(\"Mobx Injector: you are trying to attach `contextTypes` on an component decorated with `inject` (or `observer`) HOC. Please specify the contextTypes on the wrapped component instead. It is accessible through the `wrappedComponent`\");\n        },\n        configurable: true,\n        enumerable: false\n    },\n    isMobxInjector: {\n        value: true,\n        writable: true,\n        configurable: true,\n        enumerable: true\n    }\n\n    /**\n     * Store Injection\n     */\n};function createStoreInjector(grabStoresFn, component, injectNames) {\n    var _class, _temp2;\n\n    var displayName = \"inject-\" + (component.displayName || component.name || component.constructor && component.constructor.name || \"Unknown\");\n    if (injectNames) displayName += \"-with-\" + injectNames;\n\n    var Injector = (_temp2 = _class = function (_Component) {\n        inherits(Injector, _Component);\n\n        function Injector() {\n            var _ref;\n\n            var _temp, _this, _ret;\n\n            classCallCheck(this, Injector);\n\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Injector.__proto__ || Object.getPrototypeOf(Injector)).call.apply(_ref, [this].concat(args))), _this), _this.storeRef = function (instance) {\n                _this.wrappedInstance = instance;\n            }, _temp), possibleConstructorReturn(_this, _ret);\n        }\n\n        createClass(Injector, [{\n            key: \"render\",\n            value: function render() {\n                // Optimization: it might be more efficient to apply the mapper function *outside* the render method\n                // (if the mapper is a function), that could avoid expensive(?) re-rendering of the injector component\n                // See this test: 'using a custom injector is not too reactive' in inject.js\n                var newProps = {};\n                for (var key in this.props) {\n                    if (this.props.hasOwnProperty(key)) {\n                        newProps[key] = this.props[key];\n                    }\n                }var additionalProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context) || {};\n                for (var _key2 in additionalProps) {\n                    newProps[_key2] = additionalProps[_key2];\n                }\n\n                if (!isStateless(component)) {\n                    newProps.ref = this.storeRef;\n                }\n\n                return createElement(component, newProps);\n            }\n        }]);\n        return Injector;\n    }(Component), _class.displayName = displayName, _temp2);\n\n    // Static fields from component should be visible on the generated Injector\n\n    hoistNonReactStatics(Injector, component);\n\n    Injector.wrappedComponent = component;\n    Object.defineProperties(Injector, proxiedInjectorProps);\n\n    return Injector;\n}\n\nfunction grabStoresByName(storeNames) {\n    return function (baseStores, nextProps) {\n        storeNames.forEach(function (storeName) {\n            if (storeName in nextProps // prefer props over stores\n            ) return;\n            if (!(storeName in baseStores)) throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n            nextProps[storeName] = baseStores[storeName];\n        });\n        return nextProps;\n    };\n}\n\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nfunction inject() /* fn(stores, nextProps) or ...storeNames */{\n    var grabStoresFn = void 0;\n    if (typeof arguments[0] === \"function\") {\n        grabStoresFn = arguments[0];\n        return function (componentClass) {\n            var injected = createStoreInjector(grabStoresFn, componentClass);\n            injected.isMobxInjector = false; // supress warning\n            // mark the Injector as observer, to make it react to expressions in `grabStoresFn`,\n            // see #111\n            injected = observer(injected);\n            injected.isMobxInjector = true; // restore warning\n            return injected;\n        };\n    } else {\n        var storeNames = [];\n        for (var i = 0; i < arguments.length; i++) {\n            storeNames[i] = arguments[i];\n        }grabStoresFn = grabStoresByName(storeNames);\n        return function (componentClass) {\n            return createStoreInjector(grabStoresFn, componentClass, storeNames.join(\"-\"));\n        };\n    }\n}\n\n/**\n * dev tool support\n */\nvar isDevtoolsEnabled = false;\n\nvar isUsingStaticRendering = false;\n\nvar warnedAboutObserverInjectDeprecation = false;\n\n// WeakMap<Node, Object>;\nvar componentByNodeRegistery = typeof WeakMap !== \"undefined\" ? new WeakMap() : undefined;\nvar renderReporter = new EventEmitter();\n\nfunction findDOMNode$2(component) {\n    if (findDOMNode) {\n        try {\n            return findDOMNode(component);\n        } catch (e) {\n            // findDOMNode will throw in react-test-renderer, see:\n            // See https://github.com/mobxjs/mobx-react/issues/216\n            // Is there a better heuristic?\n            return null;\n        }\n    }\n    return null;\n}\n\nfunction reportRendering(component) {\n    var node = findDOMNode$2(component);\n    if (node && componentByNodeRegistery) componentByNodeRegistery.set(node, component);\n\n    renderReporter.emit({\n        event: \"render\",\n        renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,\n        totalTime: Date.now() - component.__$mobRenderStart,\n        component: component,\n        node: node\n    });\n}\n\nfunction trackComponents() {\n    if (typeof WeakMap === \"undefined\") throw new Error(\"[mobx-react] tracking components is not supported in this browser.\");\n    if (!isDevtoolsEnabled) isDevtoolsEnabled = true;\n}\n\nfunction useStaticRendering(useStaticRendering) {\n    isUsingStaticRendering = useStaticRendering;\n}\n\n/**\n * Errors reporter\n */\n\nvar errorsReporter = new EventEmitter();\n\n/**\n * Utilities\n */\n\nfunction patch(target, funcName) {\n    var runMixinFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var base = target[funcName];\n    var mixinFunc = reactiveMixin[funcName];\n    var f = !base ? mixinFunc : runMixinFirst === true ? function () {\n        mixinFunc.apply(this, arguments);\n        base.apply(this, arguments);\n    } : function () {\n        base.apply(this, arguments);\n        mixinFunc.apply(this, arguments);\n    };\n\n    // MWE: ideally we freeze here to protect against accidental overwrites in component instances, see #195\n    // ...but that breaks react-hot-loader, see #231...\n    target[funcName] = f;\n}\n\nfunction isObjectShallowModified(prev, next) {\n    if (null == prev || null == next || (typeof prev === \"undefined\" ? \"undefined\" : _typeof(prev)) !== \"object\" || (typeof next === \"undefined\" ? \"undefined\" : _typeof(next)) !== \"object\") {\n        return prev !== next;\n    }\n    var keys = Object.keys(prev);\n    if (keys.length !== Object.keys(next).length) {\n        return true;\n    }\n    var key = void 0;\n    for (var i = keys.length - 1; i >= 0, key = keys[i]; i--) {\n        if (next[key] !== prev[key]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * ReactiveMixin\n */\nvar reactiveMixin = {\n    componentWillMount: function componentWillMount() {\n        var _this = this;\n\n        if (isUsingStaticRendering === true) return;\n        // Generate friendly name for debugging\n        var initialName = this.displayName || this.name || this.constructor && (this.constructor.displayName || this.constructor.name) || \"<component>\";\n        var rootNodeID = this._reactInternalInstance && this._reactInternalInstance._rootNodeID;\n\n        /**\n         * If props are shallowly modified, react will render anyway,\n         * so atom.reportChanged() should not result in yet another re-render\n         */\n        var skipRender = false;\n        /**\n         * forceUpdate will re-assign this.props. We don't want that to cause a loop,\n         * so detect these changes\n         */\n        var isForcingUpdate = false;\n\n        function makePropertyObservableReference(propName) {\n            var valueHolder = this[propName];\n            var atom = new Atom(\"reactive \" + propName);\n            Object.defineProperty(this, propName, {\n                configurable: true,\n                enumerable: true,\n                get: function get$$1() {\n                    atom.reportObserved();\n                    return valueHolder;\n                },\n                set: function set$$1(v) {\n                    if (!isForcingUpdate && isObjectShallowModified(valueHolder, v)) {\n                        valueHolder = v;\n                        skipRender = true;\n                        atom.reportChanged();\n                        skipRender = false;\n                    } else {\n                        valueHolder = v;\n                    }\n                }\n            });\n        }\n\n        // make this.props an observable reference, see #124\n        makePropertyObservableReference.call(this, \"props\");\n        // make state an observable reference\n        makePropertyObservableReference.call(this, \"state\");\n\n        // wire up reactive render\n        var baseRender = this.render.bind(this);\n        var reaction = null;\n        var isRenderingPending = false;\n\n        var initialRender = function initialRender() {\n            reaction = new Reaction(initialName + \"#\" + rootNodeID + \".render()\", function () {\n                if (!isRenderingPending) {\n                    // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n                    // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n                    // See #85 / Pull #44\n                    isRenderingPending = true;\n                    if (typeof _this.componentWillReact === \"function\") _this.componentWillReact(); // TODO: wrap in action?\n                    if (_this.__$mobxIsUnmounted !== true) {\n                        // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted\n                        // TODO: remove this check? Then react will properly warn about the fact that this should not happen? See #73\n                        // However, people also claim this migth happen during unit tests..\n                        var hasError = true;\n                        try {\n                            isForcingUpdate = true;\n                            if (!skipRender) Component.prototype.forceUpdate.call(_this);\n                            hasError = false;\n                        } finally {\n                            isForcingUpdate = false;\n                            if (hasError) reaction.dispose();\n                        }\n                    }\n                }\n            });\n            reaction.reactComponent = _this;\n            reactiveRender.$mobx = reaction;\n            _this.render = reactiveRender;\n            return reactiveRender();\n        };\n\n        var reactiveRender = function reactiveRender() {\n            isRenderingPending = false;\n            var exception = undefined;\n            var rendering = undefined;\n            reaction.track(function () {\n                if (isDevtoolsEnabled) {\n                    _this.__$mobRenderStart = Date.now();\n                }\n                try {\n                    rendering = extras.allowStateChanges(false, baseRender);\n                } catch (e) {\n                    exception = e;\n                }\n                if (isDevtoolsEnabled) {\n                    _this.__$mobRenderEnd = Date.now();\n                }\n            });\n            if (exception) {\n                errorsReporter.emit(exception);\n                throw exception;\n            }\n            return rendering;\n        };\n\n        this.render = initialRender;\n    },\n\n    componentWillUnmount: function componentWillUnmount() {\n        if (isUsingStaticRendering === true) return;\n        this.render.$mobx && this.render.$mobx.dispose();\n        this.__$mobxIsUnmounted = true;\n        if (isDevtoolsEnabled) {\n            var node = findDOMNode$2(this);\n            if (node && componentByNodeRegistery) {\n                componentByNodeRegistery.delete(node);\n            }\n            renderReporter.emit({\n                event: \"destroy\",\n                component: this,\n                node: node\n            });\n        }\n    },\n\n    componentDidMount: function componentDidMount() {\n        if (isDevtoolsEnabled) {\n            reportRendering(this);\n        }\n    },\n\n    componentDidUpdate: function componentDidUpdate() {\n        if (isDevtoolsEnabled) {\n            reportRendering(this);\n        }\n    },\n\n    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {\n        if (isUsingStaticRendering) {\n            console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n        }\n        // update on any state changes (as is the default)\n        if (this.state !== nextState) {\n            return true;\n        }\n        // update if props are shallowly not equal, inspired by PureRenderMixin\n        // we could return just 'false' here, and avoid the `skipRender` checks etc\n        // however, it is nicer if lifecycle events are triggered like usually,\n        // so we return true here if props are shallowly modified.\n        return isObjectShallowModified(this.props, nextProps);\n    }\n\n    /**\n     * Observer function / decorator\n     */\n};function observer(arg1, arg2) {\n    if (typeof arg1 === \"string\") {\n        throw new Error(\"Store names should be provided as array\");\n    }\n    if (Array.isArray(arg1)) {\n        // component needs stores\n        if (!warnedAboutObserverInjectDeprecation) {\n            warnedAboutObserverInjectDeprecation = true;\n            console.warn('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject(\"store1\", \"store2\") @observer ComponentClass` or `inject(\"store1\", \"store2\")(observer(componentClass))` instead of `@observer([\"store1\", \"store2\"]) ComponentClass`');\n        }\n        if (!arg2) {\n            // invoked as decorator\n            return function (componentClass) {\n                return observer(arg1, componentClass);\n            };\n        } else {\n            return inject.apply(null, arg1)(observer(arg2));\n        }\n    }\n    var componentClass = arg1;\n\n    if (componentClass.isMobxInjector === true) {\n        console.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\");\n    }\n\n    // Stateless function component:\n    // If it is function but doesn't seem to be a react class constructor,\n    // wrap it to a react class automatically\n    if (typeof componentClass === \"function\" && (!componentClass.prototype || !componentClass.prototype.render) && !componentClass.isReactClass && !Component.isPrototypeOf(componentClass)) {\n        var _class, _temp;\n\n        return observer((_temp = _class = function (_Component) {\n            inherits(_class, _Component);\n\n            function _class() {\n                classCallCheck(this, _class);\n                return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n            }\n\n            createClass(_class, [{\n                key: \"render\",\n                value: function render() {\n                    return componentClass.call(this, this.props, this.context);\n                }\n            }]);\n            return _class;\n        }(Component), _class.displayName = componentClass.displayName || componentClass.name, _class.contextTypes = componentClass.contextTypes, _class.propTypes = componentClass.propTypes, _class.defaultProps = componentClass.defaultProps, _temp));\n    }\n\n    if (!componentClass) {\n        throw new Error(\"Please pass a valid component to 'observer'\");\n    }\n\n    var target = componentClass.prototype || componentClass;\n    mixinLifecycleEvents(target);\n    componentClass.isMobXReactObserver = true;\n    return componentClass;\n}\n\nfunction mixinLifecycleEvents(target) {\n    patch(target, \"componentWillMount\", true);[\"componentDidMount\", \"componentWillUnmount\", \"componentDidUpdate\"].forEach(function (funcName) {\n        patch(target, funcName);\n    });\n    if (!target.shouldComponentUpdate) {\n        target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;\n    }\n}\n\n// TODO: support injection somehow as well?\nvar Observer = observer(function (_ref) {\n    var children = _ref.children;\n    return children();\n});\n\nObserver.displayName = \"Observer\";\n\nObserver.propTypes = {\n    children: function children(propValue, key, componentName, location, propFullName) {\n        if (typeof propValue[key] !== \"function\") return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + _typeof(propValue[key]) + \"` supplied to\" + \" `\" + componentName + \"`, expected `function`.\");\n    }\n};\n\nvar _class;\nvar _temp;\n\nvar specialReactKeys = { children: true, key: true, ref: true };\n\nvar Provider = (_temp = _class = function (_Component) {\n    inherits(Provider, _Component);\n\n    function Provider() {\n        classCallCheck(this, Provider);\n        return possibleConstructorReturn(this, (Provider.__proto__ || Object.getPrototypeOf(Provider)).apply(this, arguments));\n    }\n\n    createClass(Provider, [{\n        key: \"render\",\n        value: function render() {\n            return Children.only(this.props.children);\n        }\n    }, {\n        key: \"getChildContext\",\n        value: function getChildContext() {\n            var stores = {};\n            // inherit stores\n            var baseStores = this.context.mobxStores;\n            if (baseStores) for (var key in baseStores) {\n                stores[key] = baseStores[key];\n            }\n            // add own stores\n            for (var _key in this.props) {\n                if (!specialReactKeys[_key] && _key !== \"suppressChangedStoreWarning\") stores[_key] = this.props[_key];\n            }return {\n                mobxStores: stores\n            };\n        }\n    }, {\n        key: \"componentWillReceiveProps\",\n        value: function componentWillReceiveProps(nextProps) {\n            // Maybe this warning is too aggressive?\n            if (Object.keys(nextProps).length !== Object.keys(this.props).length) console.warn(\"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\");\n            if (!nextProps.suppressChangedStoreWarning) for (var key in nextProps) {\n                if (!specialReactKeys[key] && this.props[key] !== nextProps[key]) console.warn(\"MobX Provider: Provided store '\" + key + \"' has changed. Please avoid replacing stores as the change might not propagate to all children\");\n            }\n        }\n    }]);\n    return Provider;\n}(Component), _class.contextTypes = {\n    mobxStores: objectOrObservableObject\n}, _class.childContextTypes = {\n    mobxStores: objectOrObservableObject.isRequired\n}, _temp);\n\nif (!Component) throw new Error(\"mobx-react requires React to be available\");\nif (!extras) throw new Error(\"mobx-react requires mobx to be available\");\n\nif (typeof unstable_batchedUpdates === \"function\") extras.setReactionScheduler(unstable_batchedUpdates);else if (typeof unstable_batchedUpdates$1 === \"function\") extras.setReactionScheduler(unstable_batchedUpdates$1);\n\nvar onError = function onError(fn) {\n    return errorsReporter.on(fn);\n};\n\n/* DevTool support */\n// See: https://github.com/andykog/mobx-devtools/blob/d8976c24b8cb727ed59f9a0bc905a009df79e221/src/backend/installGlobalHook.js\n\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    var mobx$1 = { spy: spy, extras: extras };\n    var mobxReact = { renderReporter: renderReporter, componentByNodeRegistery: componentByNodeRegistery, trackComponents: trackComponents };\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobxReact(mobxReact, mobx$1);\n}\n\nexport { propTypes, propTypes as PropTypes, onError, observer, Observer, renderReporter, componentByNodeRegistery, trackComponents, useStaticRendering, Provider, inject };\n","/* eslint-disable import/prefer-default-export */\nimport React from 'react'\nimport { autorun, isObservable, toJS } from 'mobx'\nimport shallowEqual from 'fbjs/lib/shallowEqual'\n\nexport const inject = injectFunction => Component => class extends React.Component {\n  static contextTypes = {\n    mobxStores: () => null, // this is to avoid importing prop-types\n  }\n\n  constructor(props, context) {\n    super(props, context)\n\n    this.state = {\n      injectedProps: {},\n    }\n\n    let firstRun = true\n    this.dispose = autorun(() => {\n      // rerun store mapping so the flat values are processed again\n      // FIXME: Pass this.props ? Then we should call\n      //        the whole function on `componentWillReceiveProps`\n      const injected = injectFunction(this.context.mobxStores)\n\n      // copy to make sure we don't mutate an object that could be used by the inject\n      const injectedProps = { ...injected }\n\n      // flatten mobx observables\n      Object.keys(injectedProps).forEach((key) => {\n        const value = injectedProps[key]\n        if (isObservable(value)) {\n          injectedProps[key] = toJS(injectedProps[key])\n        }\n      })\n\n      // on first run we have to use this.state, not this.setState\n      if (firstRun) {\n        firstRun = false\n        this.state = { ...this.state, injectedProps }\n      } else if (!shallowEqual(injectedProps, this.state.injectedProps)) {\n        this.setState(prevState => ({ ...prevState, injectedProps }))\n      }\n    })\n  }\n\n  /* unbind observable reaction */\n  componentWillUnmount() {\n    this.dispose()\n  }\n\n  render() {\n    return (\n      <Component\n        /* this is parent props */\n        {...this.props}\n        /* this is injected props from hoc */\n        {...this.state.injectedProps}\n      />\n    )\n  }\n}\n"],"names":["createChainableTypeChecker","validate","checkType","isRequired","props","propName","componentName","location","propFullName","_len","arguments","length","rest","Array","_key","untracked","actual","Error","apply","undefined","concat","chainedCheckType","bind","getPropType","propValue","propType","_typeof","isArray","RegExp","Symbol","isSymbol","createObservableTypeCheckerCreator","allowNativeType","mobxType","toLowerCase","mobxChecker","isObservableArray","isObservableObject","isObservableMap","preciseType","Date","getPreciseType","nativeTypeExpectationMessage","createObservableArrayOfTypeChecker","typeChecker","_len2","_key2","error","i","createStoreInjector","grabStoresFn","component","injectNames","_class","_temp2","displayName","name","constructor","Injector","_Component","_ref","_temp","_this","_ret","this","args","possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","storeRef","instance","wrappedInstance","newProps","key","hasOwnProperty","additionalProps","context","mobxStores","prototype","render","isStateless","ref","createElement","Component","wrappedComponent","defineProperties","proxiedInjectorProps","inject","componentClass","injected","isMobxInjector","observer","storeNames","baseStores","nextProps","forEach","storeName","grabStoresByName","join","findDOMNode$2","findDOMNode","e","reportRendering","node","componentByNodeRegistery","set","emit","__$mobRenderEnd","__$mobRenderStart","now","patch","target","funcName","runMixinFirst","base","mixinFunc","reactiveMixin","f","isObjectShallowModified","prev","next","keys","arg1","arg2","warnedAboutObserverInjectDeprecation","warn","isReactClass","isPrototypeOf","contextTypes","propTypes","defaultProps","shouldComponentUpdate","isMobXReactObserver","babelHelpers.typeof","iterator","obj","classCallCheck","Constructor","TypeError","createClass","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","inherits","subClass","superClass","create","setPrototypeOf","self","ReferenceError","EventEmitter","listeners","cb","push","index","indexOf","splice","data","fn","REACT_STATICS","KNOWN_STATICS","defineProperty$1","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","objectPrototype","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","inheritedComponent","observableArray","observableArrayOf","observableMap","observableObject","arrayOrObservableArray","arrayOrObservableArrayOf","objectOrObservableObject","injectorContextTypes","freeze","seal","_","isDevtoolsEnabled","WeakMap","renderReporter","errorsReporter","makePropertyObservableReference","valueHolder","atom","Atom","reportObserved","v","isForcingUpdate","reportChanged","initialName","rootNodeID","_reactInternalInstance","_rootNodeID","skipRender","baseRender","reaction","isRenderingPending","reactiveRender","exception","rendering","track","extras","allowStateChanges","Reaction","componentWillReact","__$mobxIsUnmounted","hasError","forceUpdate","dispose","reactComponent","$mobx","delete","nextState","state","Observer","children","specialReactKeys","Provider","Children","only","stores","console","suppressChangedStoreWarning","childContextTypes","unstable_batchedUpdates","setReactionScheduler","__MOBX_DEVTOOLS_GLOBAL_HOOK__","mobx$1","spy","mobxReact","trackComponents","injectMobxReact","firstRun","autorun","injectFunction","injectedProps","value","isObservable","toJS","shallowEqual","setState","prevState","React"],"mappings":"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"}